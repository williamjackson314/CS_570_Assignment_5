/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ssnfs.h"

// Not RPC Gen code here
// --------------------------------------------------------------------
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <pwd.h>

#define MAX_FILES 20
#define BLOCK_SIZE 512
#define FILE_SIZE 64    // Blocks
#define FILE_SIZE_BYTES (FILE_SIZE * BLOCK_SIZE * MAX_FILES)
#define LATEST_FILE server_file_table.files[server_file_table.num_files - 1]

// Data structure for file info
typedef struct file_info {
	char user_name[USER_NAME_SIZE];
	char file_name[FILE_NAME_SIZE];
    int fd;
} file_info;

typedef struct file_table {
    file_info files[MAX_FILES];
    int num_files;
} file_table;

file_table server_file_table; //= {.files[0] = (char *) malloc(MAX_FILES*sizeof(file_info)), .num_files = 0};
// --------------------------------------------------------------------



open_output *
open_file_1_svc(open_input *argp, struct svc_req *rqstp)
{
	static open_output  result;

	if (server_file_table.num_files == MAX_FILES){
        sprintf(result.out_msg.out_msg_val, "%s", strerror(errno));
    }
	
	server_file_table.num_files++;

	result.fd=20; //TODO Figure out what to put here
	result.out_msg.out_msg_len=20; //TODO Figure out where this number came from
	
	free(result.out_msg.out_msg_val);
	result.out_msg.out_msg_val=(char *) malloc(result.out_msg.out_msg_len);
    strcpy(result.out_msg.out_msg_val, (*argp).file_name);
	printf("In server: filename recieved:%s\n",argp->file_name);
	printf("In server username received:%s\n",argp->user_name);

	// FIXME: result.out_msg.out_msg_val = ???; Figure out how to set out message length
	// FIXME strcpy(result.out_msg.out_msg_val, (*argp).file_name);
	// TODO ask prof if I need to populate anything other than result.fd for this server


	// FIXME: make sure argument types correct for strcpy 
    // strcpy(server_file_table.files[server_file_table.num_files - 1].file_name, (*argp).file_name);
    // server_file_table.files[server_file_table.num_files - 1].fd = result.fd;
    // strcpy(server_file_table.files[server_file_table.num_files - 1].user_name, getpwuid(getuid())->pw_name);

	// strcpy(server_file_table.files[0].file_name, (*argp).file_name);
    // server_file_table.files[0].fd = result.fd;
    // strcpy(server_file_table.files[0].user_name, getpwuid(getuid())->pw_name);

	// printf("File %s added to file table", server_file_table.files[0].file_name);
	return &result;
}

read_output *
read_file_1_svc(read_input *argp, struct svc_req *rqstp)
{
	static read_output  result;

	// TODO Check if username matches for permissions purposes
    int num_bytes = read((* argp).fd, result.buffer.buffer_val, (* argp).numbytes);

	// FIXME Make sure don't need to return any more info to client
    if (num_bytes = -1){
        sprintf(result.out_msg.out_msg_val, "%s", strerror(errno));
    }


    // TODO Make sure this is returning proper error if trying to read past the
    // end of file, file descriptor passed was not correct,

	return &result;
}

// TODO Implement write file function
write_output *
write_file_1_svc(write_input *argp, struct svc_req *rqstp)
{
	static write_output  result;

	// TODO Check if username matches for permissions purposes
	printf("Attempting to write to file.");
	int bytes_written = write(argp->fd, argp->buffer.buffer_val, argp->numbytes);
	if (bytes_written == -1){
		result.out_msg.out_msg_len = sizeof(strerror(errno));
		sprintf(result.out_msg.out_msg_val, "%s", strerror(errno));
	}

	return &result;
}

list_output *
list_files_1_svc(list_input *argp, struct svc_req *rqstp)
{
	static list_output  result;

	for (int i=0;i<server_file_table.num_files;i++){
        if (strcmp(server_file_table.files[i].user_name, argp->user_name) == 0){
            sprintf(result.out_msg.out_msg_val, "%s", server_file_table.files[i].file_name); //FIXME Append to out_msg instead of just overwriting everytime
        }
    }

	return &result;
}

delete_output *
delete_file_1_svc(delete_input *argp, struct svc_req *rqstp)
{
	static delete_output  result;

	// TODO Check if username matches for permissions purposes
    int val = remove(argp->file_name);
    if (val == -1){
        sprintf(result.out_msg.out_msg_val, "%s", strerror(errno));
    }

	return &result;
}

close_output *
close_file_1_svc(close_input *argp, struct svc_req *rqstp)
{
	static close_output  result;

	// TODO Check if username matches for permissions purposes
    int val = close(argp->fd);
    if (val == -1){
        sprintf(result.out_msg.out_msg_val, "%s", strerror(errno));
    }

	return &result;
}

seek_output *
seek_position_1_svc(seek_input *argp, struct svc_req *rqstp)
{
	static seek_output  result;

	// TODO Check if username matches for permissions purposes
	lseek(argp->fd, argp->position, SEEK_CUR);

	return &result;
}

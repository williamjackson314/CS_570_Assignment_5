/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ssnfs.h"

// Not RPC Gen code here
// --------------------------------------------------------------------
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <pwd.h>

#define MAX_FILES 20
#define BLOCK_SIZE 512
#define FILE_SIZE 64    // Blocks
#define FILE_DISK_SIZE (FILE_SIZE * BLOCK_SIZE * MAX_FILES)
#define LATEST_FILE server_file_table.files[server_file_table.num_files - 1]

// Data structure for file info
typedef struct file_info {
	char user_name[USER_NAME_SIZE];
	char file_name[FILE_NAME_SIZE];
    int fd;
} file_info;

typedef struct file_table {
    file_info files[MAX_FILES];
    int num_files;
} file_table;

file_table server_file_table;
// --------------------------------------------------------------------



open_output *
open_file_1_svc(open_input *argp, struct svc_req *rqstp)
{
	static open_output  result;

	// TODO Error checking for file opening
	// if (server_file_table.num_files == MAX_FILES){
    //     printf("File table full.");
    //     return -1;
    // }
	
	server_file_table.num_files++;
    
    result.fd = open((* argp).file_name, O_RDWR);

    // if (result.fd == -1){
    //     printf("%s\n", strerror(errno));
    // }

    ftruncate(result.fd, FILE_SIZE * BLOCK_SIZE);

	// FIXME: result.out_msg.out_msg_val = ???; Figure out how to set out message length
	// FIXME strcpy(result.out_msg.out_msg_val, (*argp).file_name);
	// TODO ask prof if I need to populate anything other than result.fd for this server


	// FIXME: make sure argument types correct for strcpy 
    strcpy(server_file_table.files[server_file_table.num_files - 1].file_name, (*argp).file_name);
    server_file_table.files[server_file_table.num_files - 1].fd = result.fd;
    strcpy(server_file_table.files[server_file_table.num_files - 1].user_name, getpwuid(getuid())->pw_name);

    //TODO: Add check for space on files.dat


	return &result;
}

read_output *
read_file_1_svc(read_input *argp, struct svc_req *rqstp)
{
	static read_output  result;

    int num_bytes = read((* argp).fd, result.buffer.buffer_val, (* argp).numbytes);

	// TODO Error checking
    // if (num_bytes = -1){
    //     printf("%s", strerror(errno));
    //     return -1;
    // }


    // TODO Make sure this is returning proper error if trying to read past the
    // end of file, file descriptor passed was not correct,

	return &result;
}

write_output *
write_file_1_svc(write_input *argp, struct svc_req *rqstp)
{
	static write_output  result;

	/*
	 * insert server code here
	 */

	return &result;
}

list_output *
list_files_1_svc(list_input *argp, struct svc_req *rqstp)
{
	static list_output  result;

	/*
	 * insert server code here
	 */

	return &result;
}

delete_output *
delete_file_1_svc(delete_input *argp, struct svc_req *rqstp)
{
	static delete_output  result;

	/*
	 * insert server code here
	 */

	return &result;
}

close_output *
close_file_1_svc(close_input *argp, struct svc_req *rqstp)
{
	static close_output  result;

	/*
	 * insert server code here
	 */

	return &result;
}

seek_output *
seek_position_1_svc(seek_input *argp, struct svc_req *rqstp)
{
	static seek_output  result;

	/*
	 * insert server code here
	 */

	return &result;
}
